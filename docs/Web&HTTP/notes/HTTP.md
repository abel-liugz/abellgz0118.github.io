---
title: HTTP
---

# HTTP

- 浏览器给服务端发送的内容称为Resquest
  - 请求行
    - 是一行字符串，以连续的两个回车符和换行符作为结束这一行的标志
    - 请求方式(SP)抽象路径(SP)协议版本(CRLF)
    - GET /myweb/index.html HTTP/1.1
    - GET / HTTP/1.1
  - 消息头
    - 消息头由若干行组成，每行结束也是以CRLF标志。
    - 每个消息头的格式为:消息头的名字(:SP)消息的值(CRLF)
    - 消息头部分结束是以单独的(CRLF)标志。
  - 消息正文
    - 消息正文是2进制数据，通常是用户上传的信息
- 服务端给浏览器发送的内容称为Response
  - 状态行
    - 状态行是一行字符串(CRLF结尾)，并且状态行由三部分组成，格式为：
    - protocol(SP)statusCode(SP)statusReason(CRLF)
    - 协议版本(SP)状态代码(SP)状态描述(CRLF)
  - 响应头
    - 响应头与请求中的消息头格式一致，表示的是服务端发送给客户端的附加信息。
  - 响应正文
    - 2进制数据部分，包含的通常是客户端实际请求的资源内容。



## 常见HTTP响应码

官方文档（英文版）：

官方文档（中文版）：

常见HTTP响应码通俗描述：

- 200：成功响应，需要注意，这仅仅表示服务器端成功的进行了响应这项操作，并不代表业务的成功，例如尝试登录时，如果用户名或密码错误导致登录失败，只要服务器端成功的响应了，响应码也是200
- 302：重定向，服务器端处理请求后，会响应此响应码和另一个目标路径，通常，浏览器收到此响应码后悔自动请求新的目标路径
- 400：请求参数错误，例如服务器端对某个请求参数设置了“不允许为null”的预定，而客户端却未提交此参数，或某请求参数必须是数值类型的，客户端提交的却是一个无法转换为数值类型的参数值
  - 出现此问题时，通过断点或打桩等方式观察提交的请求参数，并查看服务器端对请求参数的约束
    - 在Spring MVC框架中，@RequestParam默认具有“不允许为null”的约定
    - 在Spring MVC框架中，会尝试自动将请求参数转换为服务器端上面的参数类型
    - 在Spring MVC框架中，使用了Hibernate Validatißon验证机制后，也会对请求参数产生约束，具体约束需要参考所使用得注解
    - 基于以上框架的进阶框架具有同样效果，例如添加了spring-boot-starter-web依赖项的Spring Boot工程是使用Spring MVC接收请求参数的，添加了spring-boor-starter-validation依赖项的Spring Boot工程则是使用Hibernate Validation实现的请求参数验证
- 401：未授权，通常出现在未登录，却尝试请求必须登录才允许方法的资源时
- 403：禁止访问，通常出现在已经登录，却不具备访问权限时，例如普通用户尝试请求管理员的资源时
  - 出现此问题时，如果使用了Spring Security框架，应该检查Spring Security的配置类中的相关配置，例如白名单路径，并检查是否开启了授权访问，如果已开启，还应该用过断言或打桩等方式观察当前登录用户的权限清单，并检查在请求资源上设置的权限规则
- 404：请求的资源不存在，通常是客户端提交请求的URL错误
  - 出现此问题时，应该检查客户端提交请求的URL与服务器端设置的接受请求参数的URL是否一致
  - 在确保客户端提交请求的URL是预期的时，关于服务器应该：
    - 如果请求的是服务器端的某个静态资源，应该检查此资源是否存在，在Spring Boot工程中，默认的静态资源文件夹是src/main/resources/static，并且需要注意，如果显式的配置了静态资源文件夹，将会覆盖此默认项
    - 如果服务器端是用过Spring MVC框架开发的，应该检查：
      - 控制器是否已经正常启用，可以在控制器类中显式的添加无参构造方法，并在其中输出任何内容，当启动项目时，你应该可以在控制台看到输出语句中的内容，如果看不到，则表示控制器没有被创建，则需要检查组件扫描配置的包、控制器类是否添加了@Controller或@RestController注解，如果使用得是Spring Boot工程，默认组件扫描的包是创建工程时指定的Group Id和Artifact ID组件的包名
      - 请求路径是由控制器类上的@RequestMapping注解（如果存在的话）和处理请求的方法上的@RequestMapping或以此为元注解的其他注解组合得到的，应该检查这两处的注解
- 405：请求方式错误，例如服务器端要求使用POST方式提交请求，而客户端却使用GET方式提交请求
  - 出现此问题时，应该检查客户端的请求方式，如果是直接在浏览器的地址栏中输入URL提交的请求，是GET方式的，如果是用过HTML表单或其他异步提交方式，除非显示的使用POST方式，否则都是GET方式的，另外，在服务器端，需要检查如何配置的请求URL，例如使用@PostMapping时，则限制了客户端的请求方式必须是POST
- 406：不可接收的，
- 500：服务器内部错误，通常是因为服务器端出现了异常且始终未显式的捕获
  - 出现此问题时，你应该检查服务器端控制台的异常信息，如果无信息，你应该检查项目中是否使用了Spring MVC统一处理异常的机制，并且在处理异常时未添加`e.printStackTrace()`等方式将异常信息输出



## 会话管理

- 客户端和服务器之间进行数据传输遵循的是HTTP协议，此协议属于无状态协议（一次请求对应一次响应，响应完成后链接就会断开），服务器是无法跟踪客户端的请求，通过Cookie服务器可以给客户端添加一个标识，当客户端再次发出请求时会带着这个Cookie，这样服务器就能识别此客户端了，但是由于Cookie是保存在客户端的，存在被纂改的风险，Session的出现解决了测问题
- Cookie：相当于打孔式会员卡，数据保存在客户端
  - 只能保存字符串数据
  - 默认数据是保存在浏览器内存中，当回话结束（浏览器关闭）数据会删除，也可以设置自定义的保存时长，设置完后数据会保存在磁盘在，时间到了后清除
  - 应用场景：需要长时间保存的数据，比如：记住用户名和密码
- Session：相当于银行卡，数据保存在服务器内存中（工程重启会清空所有Session）
  - 可以保存任意对象类型的数据
  - 默认数据只能保存半个小时左右，而且不建议修改保存时长，因为数据是保存在服务器的内存中，服务器只有一个，所有不能占用太多的内存
  - 应用场景：保存登录状态，涉及敏感数据，因为数据保存在服务器会更安全
- 如何通过Session对象记住登录状态
  1. 在登录成功时把客户端登录的user用户对象保存到当前客户端所对应的Session对象里
  2. 每个客户端进入到首页index时会立即发请求获取当前客户端登录的用户对象，服务器接收到请求后会从当前客户端所对应的Session对象里面获取曾经保存过的用户对象（前提是登陆过），如果没有登录之间获取得到的是null返回给客户端，测试客户端得到是空字符串，客户端判断是否是空字符串来表示是否登陆过，通过isLogin赋值true或false来控制页面显示的内容