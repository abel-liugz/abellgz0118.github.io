<template><div><h2 id="什么是类-什么是对象" tabindex="-1"><a class="header-anchor" href="#什么是类-什么是对象" aria-hidden="true">#</a> 什么是类？什么是对象</h2>
<ul>
<li>类：类别、类型，代表一类个体</li>
<li>对象：软件中真实存在的单个个体、东西</li>
<li>类是对象的模子，对象是类的具体的实例</li>
<li>类中包含：
<ul>
<li>对象的属性、特征---成员变量</li>
<li>对象的行为、动作---方法</li>
</ul>
</li>
<li>一个类可以创建多个对象</li>
</ul>
<h2 id="三大特征" tabindex="-1"><a class="header-anchor" href="#三大特征" aria-hidden="true">#</a> 三大特征：</h2>
<ul>
<li>
<p>封装：</p>
<ul>
<li>类：封装的是对象的属性和行为</li>
<li>方法：封装的是具体的业务逻辑功能实现</li>
<li>访问控制修饰符：封装的是具体的访问权限，以保护数据的安全</li>
</ul>
</li>
<li>
<p>继承</p>
<ul>
<li>
<p>作用：代码复用</p>
</li>
<li>
<p>超类：所有派生类所共有的属性和行为</p>
</li>
<li>
<p>接口：部分派生类所共有的属性和行为</p>
</li>
<li>
<p>派生类：派生类所也有的属性和行为</p>
</li>
<li>
<p>单一继承、多接口实现，具有传递性</p>
</li>
<li>
<p>java规定：构造派生类之前必须先构造超类</p>
<ul>
<li>
<p>在派生类的构造方法中若没有调用超类的构造方法，则默认super()调用超类的无参构造方法</p>
</li>
<li>
<p>在派生类的构造方法中若自己调用了超类的构造方法，则默认不在提供</p>
<blockquote>
<p>super()调用超类构造方法，必须位于派生类构造方法的第一行</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>多态</p>
<ul>
<li>意义：
<ul>
<li>同一类型的引用直线个不同类的对象时，有不同的实现-----所有抽象方法都是多态的（行为的多态）</li>
<li>同一个对象被造型为不同类型是，有不同的功能-----所有对象都是多态的（对象的多态）</li>
</ul>
</li>
<li>向上造型、自动类型转换：
<ul>
<li>超类型的引用指向派生类的对象</li>
<li>能点出什么，看引用的类型</li>
<li>能造型称为的数据类型有：超类+所有实现的接口</li>
</ul>
</li>
<li>强制类型转换，成功的条件：
<ul>
<li>引用所指向的对象，就是该类型</li>
<li>引用所指向的对象，实现了该接口或继承了该类</li>
<li>强转时若不符合以上条件，则发生ClassCastException类型转换异常，建议在强转之前先通过instanceof判断引用的对象是否是该类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="方法的重载" tabindex="-1"><a class="header-anchor" href="#方法的重载" aria-hidden="true">#</a> 方法的重载</h2>
<ul>
<li>发生在同一类中，方法名相同，参数列表不同</li>
<li>编译器在编译时会根据方法的签名自动绑定方法</li>
</ul>
<h2 id="构造方法" tabindex="-1"><a class="header-anchor" href="#构造方法" aria-hidden="true">#</a> 构造方法</h2>
<ul>
<li>作用：给成员变量赋初始值</li>
<li>与类同名，没有返回值类型（void也没有）</li>
<li>在new对象时被自动调用</li>
<li>若自己不创建构造方法，则编译器默认提供一个无参构造方法；若自己写了构造方法，则不在默认提供</li>
<li>构造方法可以重载</li>
</ul>
<h2 id="this-指代当前对象" tabindex="-1"><a class="header-anchor" href="#this-指代当前对象" aria-hidden="true">#</a> this：指代当前对象</h2>
<ul>
<li>只能用在方法中，方法中访问成员变量之前默认有个this</li>
<li>用法：
<ul>
<li>this.成员变量名-----访问成员变量</li>
<li>this.方法名()-----调用方法</li>
<li>this()-----调用构造方法</li>
</ul>
</li>
</ul>
<h2 id="super-指代当前对象的超类" tabindex="-1"><a class="header-anchor" href="#super-指代当前对象的超类" aria-hidden="true">#</a> super：指代当前对象的超类</h2>
<ol>
<li>super.成员变量名-----访问超类的成员变量</li>
<li>super.方法名()-----调用超类的方法</li>
<li>super()-----调用超类的构造方法</li>
</ol>
<h2 id="向上造型" tabindex="-1"><a class="header-anchor" href="#向上造型" aria-hidden="true">#</a> 向上造型</h2>
<blockquote>
<p>意义：代码复用</p>
</blockquote>
<ul>
<li>超类型的引用指向派生类的对象</li>
<li>能点出什么，看引用的类型</li>
</ul>
<h2 id="方法的重写" tabindex="-1"><a class="header-anchor" href="#方法的重写" aria-hidden="true">#</a> 方法的重写：</h2>
<ul>
<li>发生在父子类中，方法名相同，参数列表相同</li>
<li>重写被调用是，看对象的类型</li>
<li>重写遵循“两同两小一大”原则
<ul>
<li>两同：
<ul>
<li>方法名相同</li>
<li>参数列表相同</li>
</ul>
</li>
<li>两小：
<ul>
<li>派生类方法的返回值类型小于或等于超类方法的
<ul>
<li>void和基本类型时，必须相等</li>
<li>引用类型时，小于或等于</li>
</ul>
</li>
<li>派生类方法抛出的异常小于或等于超类方法</li>
</ul>
</li>
<li>一大：
<ul>
<li>派生类方法的访问权限大于或冬雨超类方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>重写与重载的区别：</p>
<ul>
<li>重写：发生在父子类中，方法名相同，参数列表相同</li>
<li>重载：发生在同一类中，方法名相同，参数列表不同</li>
</ul>
</blockquote>
<h2 id="package和import" tabindex="-1"><a class="header-anchor" href="#package和import" aria-hidden="true">#</a> package和import</h2>
<ul>
<li>package：声明包
<ul>
<li>避免类的命名冲突</li>
<li>同包中的类不能同名，但不同包中的类可以同名</li>
<li>类的全称：包名.类名</li>
<li>包名常常用层次结构，建议所有字母都小写</li>
</ul>
</li>
<li>import：导入类
<ul>
<li>同包中的类可以直接方法</li>
<li>不用包的类不能直接访问，若想访问：
<ol>
<li>先import声明类，再访问类</li>
<li>类的全称</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="访问控制修饰符" tabindex="-1"><a class="header-anchor" href="#访问控制修饰符" aria-hidden="true">#</a> 访问控制修饰符</h2>
<ul>
<li>public：公开的，任何类</li>
<li>private：私有的，本类</li>
<li>protected：受保护的，本类、派生类、同包类</li>
<li>默认的：什么都不写，本类、同包类</li>
</ul>
<blockquote>
<ul>
<li>类的访问权限只能是public或默认的</li>
<li>类中成员的访问权限以上4中都可以</li>
<li>反问权限由高到低：public&gt;protected&gt;默认的&gt;private</li>
</ul>
</blockquote>
<h2 id="final" tabindex="-1"><a class="header-anchor" href="#final" aria-hidden="true">#</a> final：</h2>
<ul>
<li>修饰变量：不能改变</li>
<li>修饰方法：不能被重写</li>
<li>修饰类：不能被继承</li>
</ul>
<h2 id="static" tabindex="-1"><a class="header-anchor" href="#static" aria-hidden="true">#</a> static：</h2>
<ul>
<li>静态变量：
<ul>
<li>由static修饰</li>
<li>属于类，存储在方法区中，只有一份</li>
<li>常常通过类名点来访问</li>
<li>何时用：所有对象所共享的数据(图片、音频、视频等)</li>
</ul>
</li>
<li>静态方法：
<ul>
<li>由static修饰</li>
<li>属于类，存储在方法区中，只有一份</li>
<li>常常通过类名点来访问</li>
<li>静态方法中没有隐式this传递，不能直接访问实例成员</li>
<li>何时用：方法的操作与对象无关</li>
</ul>
</li>
<li>静态块：
<ul>
<li>由static修饰</li>
<li>属于类，在类被加载期间自动执行，一个类只被加载一次，所以静态块只执行一次</li>
<li>何时用：加载/初始化静态资源(图片、音频、视频等)</li>
</ul>
</li>
</ul>
<h2 id="static-final" tabindex="-1"><a class="header-anchor" href="#static-final" aria-hidden="true">#</a> static final：</h2>
<ul>
<li>必须声明同时初始化</li>
<li>类名点来访问，不能被改变</li>
<li>常量名所有字母都大写，多个单词用_分隔</li>
<li>编译器在编译时会将常量直接替换为具体的值</li>
<li>何时用：数据永远不变，并且经常使用</li>
</ul>
<h2 id="抽象方法" tabindex="-1"><a class="header-anchor" href="#抽象方法" aria-hidden="true">#</a> 抽象方法</h2>
<ul>
<li>由abstract修饰</li>
<li>只有方法的定义，没有具体的实现</li>
</ul>
<h2 id="抽象类" tabindex="-1"><a class="header-anchor" href="#抽象类" aria-hidden="true">#</a> 抽象类</h2>
<ul>
<li>由abstract修饰</li>
<li>包含抽象方法的类必须是抽象类</li>
<li>抽象类不能被实例化（new对象）</li>
<li>抽象类是需要被继承的，派生类
<ul>
<li>重写所有抽象方法</li>
<li>也声明为抽象类</li>
</ul>
</li>
<li>抽象类的意义
<ul>
<li>封装共有的属性和行为（代码复用）</li>
<li>为所有派生类提供统一的类型（向上造型）</li>
<li>可以包含抽象方法，为所有派生类提供统一的入口，派生类的行为不同，但入口一致，同时相当于定义了一个标准（强制重写）</li>
</ul>
</li>
</ul>
<h2 id="成员内部类" tabindex="-1"><a class="header-anchor" href="#成员内部类" aria-hidden="true">#</a> 成员内部类</h2>
<ul>
<li>类中套类，外面的称为外部类，里面的称为内部类</li>
<li>内部类通常只服务于外部类，对外不具备可见性</li>
<li>内部类对象通常在外部类中创建</li>
<li>内部类中可以直接访问外部类的成员（包括私有），内部类中有个隐式的引用指向了创建它的外部类对象：外部类名.this</li>
</ul>
<h2 id="匿名内部类" tabindex="-1"><a class="header-anchor" href="#匿名内部类" aria-hidden="true">#</a> 匿名内部类</h2>
<ul>
<li>若想创建一个类的对象，并且对象只被创建一次，可以错正匿名内部类</li>
<li>在匿名内部类中默认外面的变量为final的</li>
<li>内部类有独立的class</li>
</ul>
<h2 id="接口" tabindex="-1"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h2>
<ul>
<li>是一种引用数据类型</li>
<li>由interface定义</li>
<li>只能包含常量和抽象方法</li>
<li>接口不能被实例化</li>
<li>接口是需要被实现、继承的，实现类、派生类：必须重写所有抽象方法</li>
<li>一个类可以实现多个接口，有逗号分隔，若又继承又实现，应先继承后实现</li>
<li>接口可以继承接口</li>
</ul>
</div></template>
