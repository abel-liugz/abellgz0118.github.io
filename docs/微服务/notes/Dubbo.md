---
title: Dubbo
---

# Dubbo概述

## 什么是RPC

RPC是Remote Procedure Call的缩写 翻译为:远程过程调用

目标是为了实现两台(多台)计算机\服务器,互相调用方法\通信的解决方案

RPC的概念主要定义了两部分内容

1.序列化协议

2.通信协议

为了方便大家理解RPC,下面的图片帮助理解

![本地调用.png](/images/本地调用.png)

上面图是老婆和老公在家的时,老婆让老公洗碗的调用流程

但这个流程是本地的,

我们再换成远程调用的图片

![远程调用.png](/images/远程调用.png)

**通信协议**

通信协议指的就是远程调用的通信方式

再上面图片调用中,老婆使用手机信息的方法通知老公去洗碗

实际上这个通知的方式可以有多种

例如:写信,飞鸽传书,闪送等等

**序列化协议**

序列化协议指通信内容的格式,双方都要理解这个格式

上面的图片中,老婆给老公发信息,一定是双方都能理解的信息

发送信息是序列化过程,接收信息需要反序列化

## 什么是Dubbo

理解了RPC再学习Dubbo就会简单一些了

Dubbo是一套RPC框架。既然是框架，我们可以在框架结构高度，定义Dubbo中使用的通信协议，使用的序列化框架技术，而数据格式由Dubbo定义，我们负责配置之后直接通过客户端调用服务端代码。

简单来说,Dubbo就是RPC概念的实现

Dubbo是Spring Cloud Alibaba提供的一个框架

能够实现微服务项目的互相调用

## Dubbo的发展历程

![dubbo发展历程.png](/images/dubbo发展历程.png)

2012年底dubbo停止更新后到2017年dubbo继续更新之前

2015SpringCloud开始兴起,当时没有阿里的框架

国内公司要从SpringCloud和Dubbo中抉择使用哪个微服务方案

在2012年dubbo停止更新后国内的当当网在dubbo的基础上开发了dubboX框架,并进行维护 

2019年后,SpringCloud和Dubbo才能共同使用

## Dubbo的协议支持

RPC框架分通信协议和序列化协议

Dubbo框架支持多种通信协议和序列化协议,可以通过配置文件进行修改

支持的通信协议有

* dubbo协议(默认)
* rmi协议
* hessian协议
* http协议
* webservice
* .....

支持的序列化协议

* hessian2(默认)
* java序列化
* compactedjava
* nativejava
* fastjson
* dubbo
* fst
* kryo

Dubbo默认情况下,协议的特征如下

* 采用NIO单一长连接
* 优秀的并发性能,但是大型文件的处理差
* Dubbo开发简单,有助于提升开发效率

## Dubbo服务的注册与发现

在Dubbo的调用过程中,必须包含注册中心的支持

注册中心推荐使用Nacos,但是如果使用其他软件也能实现例如(Redis,zookeeper等)

服务发现，即消费端自动发现服务地址列表的能力，是微服务框架需要具备的关键能力，借助于自动化的服务发现，微服务之间可以在无需感知对端部署位置与 IP 地址的情况下实现通信。

上面的示例中,老婆就是服务器的发现者,它能够获取老公的所有功能列表

老婆一旦调用公的服务就完成了Dubbo的调用

![dubbo注册与发现.png](/images/dubbo注册与发现.png)

consumer服务的消费者,指服务的调用者(使用者)也就是老婆的位置

provider服务的提供者,指服务的拥有者(生产者)也就是老公的位置

在Dubbo中,远程调用依据是服务的提供者在Nacos中注册的服务名称

一个服务名称,可能有多个运行的实例,任何一个空闲的实例都可以提供服务

> 常见面试题:Dubbo的注册发现流程

1.首先服务的提供者启动服务到注册中心注册,包括各种ip端口信息,Dubbo会同时注册该项目提供的远程调用的方法

2.服务的消费者(使用者)注册到注册中心,订阅发现

3.当有新的远程调用方法注册到注册中心时,注册中心会通知服务的消费者有哪些新的方法,如何调用的信息

4.RPC调用,在上面条件满足的情况下,服务的调用者无需知道ip和端口号,只需要服务名称就可以调用到服务提供者的方法

# Dubbo实现微服务调用

## 确定调用关系

![dubbo确定调用关系.png](/images/dubbo确定调用关系.png)

在上面的模型中,以order调用stock减少库存的业务举例

order模块是消费者stock模块是生产者

在代码调用时,首先要对项目进行必要的配置

我们调用时一般会在消费者项目的代码业务逻辑层中,编写调用生产者业务逻辑层方法的代码

这样做的好处

我们的生成者正常编写mapper>service>controller这个开发流程不会因为Dubbo的介入而变化

# 负载均衡

## 什么是负载均衡

![负载均衡.png](/images/负载均衡.png)

在实际开发中,一个服务基本都是集群模式的,也就是多个功能相同的项目在运行,这样才能承受更高的并发

这时一个请求到这个服务,就需要确定访问哪一个服务器

Dubbo框架内部支持负载均衡算法,能够尽可能的让请求在相对空闲的服务器上运行

我们要实现设置好负载均衡的策略算法,并设置好每个服务器的运行权重

才能更好的实现负载均衡的效果

Loadbalance:就是负载均衡的意思

## Dubbo内置负载均衡策略算法

Dubbo内置4种负载均衡算法

- **random loadbalance:随机分配策略(默认)**
- round Robin Loadbalance:权重平均分配
- leastactive Loadbalance:活跃度自动感知分配
- consistanthash Loadbalance:一致性hash算法分配

实际运行过程中,每个服务器性能不同

在负载均衡时,都会有性能权重,这些策略算法都考虑权重问题

## 随机分配策略(默认)

![负载均衡随机分配策略.png](/images/负载均衡随机分配策略.png)

随机生成随机数

在哪个范围内让哪个服务器运行

优点:

算法简单,效率高,长时间运行下,任务分配比例准确

缺点:

偶然性高,如果连续的几个随机请求发送到性能弱的服务器,会导致异常甚至宕机

## 权重平均分配

如果几个服务器权重一致,那么就是依次运行

3个服务器    1>1   2>2  3>3  4>1

但是服务器的性能权重一致的可能性很小

所以我们需要权重评价分配

Dubbo2.6.4之前平均分配权重算法是有问题的

如果3个服务器的权重比5:3:1

1>1    2>1     3>1     4>1    5>1   6>2     7>2     8>2     9>3  

10>1

Dubbo2.7之后更新了这个算法使用"**平滑加权算法**"优化权重平均分配策略

![负载均衡权重平均分配.png](/images/负载均衡权重平均分配.png)

## 活跃度自动感知

记录每个服务器处理一次请求的时间

安装时间比例来分配任务数,运行一次需要时间多的分配的请求数较少

## 一致性Hash算法

根据请求的参数进行hash运算

以后每次相同参数的请求都会访问固定服务器

因为根据参数选择服务器,不能平均分配到每台服务器上

使用的也不多

## Dubbo生产者消费者配置小结

Dubbo生产者消费者相同的配置

pom文件添加dubbo依赖,yml文件配置dubbo信息

**生产者**

* 要有service接口项目

* 提供服务的业务逻辑层实现类要添加@DubboService注解
* SpringBoot启动类要添加@EnableDubbo注解

**消费者**

* pom文件添加消费模块的service依赖
* 业务逻辑层远程调用前天模块时使用@DubboReference注解获取业务逻辑层实现类对象