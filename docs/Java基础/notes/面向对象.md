---
title: 面向对象
next: 
---

## 什么是类？什么是对象

- 类：类别、类型，代表一类个体
- 对象：软件中真实存在的单个个体、东西
- 类是对象的模子，对象是类的具体的实例
- 类中包含：
  - 对象的属性、特征---成员变量
  - 对象的行为、动作---方法
- 一个类可以创建多个对象

## 三大特征：

- 封装：

  - 类：封装的是对象的属性和行为
  - 方法：封装的是具体的业务逻辑功能实现
  - 访问控制修饰符：封装的是具体的访问权限，以保护数据的安全

- 继承

  - 作用：代码复用

  - 超类：所有派生类所共有的属性和行为

  - 接口：部分派生类所共有的属性和行为

  - 派生类：派生类所也有的属性和行为

  - 单一继承、多接口实现，具有传递性

  - java规定：构造派生类之前必须先构造超类

    - 在派生类的构造方法中若没有调用超类的构造方法，则默认super()调用超类的无参构造方法

    - 在派生类的构造方法中若自己调用了超类的构造方法，则默认不在提供

      > super()调用超类构造方法，必须位于派生类构造方法的第一行

- 多态

  - 意义：
    - 同一类型的引用直线个不同类的对象时，有不同的实现-----所有抽象方法都是多态的（行为的多态）
    - 同一个对象被造型为不同类型是，有不同的功能-----所有对象都是多态的（对象的多态）
  - 向上造型、自动类型转换：
    - 超类型的引用指向派生类的对象
    - 能点出什么，看引用的类型
    - 能造型称为的数据类型有：超类+所有实现的接口
  - 强制类型转换，成功的条件：
    - 引用所指向的对象，就是该类型
    - 引用所指向的对象，实现了该接口或继承了该类
    - 强转时若不符合以上条件，则发生ClassCastException类型转换异常，建议在强转之前先通过instanceof判断引用的对象是否是该类

## 方法的重载

- 发生在同一类中，方法名相同，参数列表不同
- 编译器在编译时会根据方法的签名自动绑定方法

## 构造方法

- 作用：给成员变量赋初始值
- 与类同名，没有返回值类型（void也没有）
- 在new对象时被自动调用
- 若自己不创建构造方法，则编译器默认提供一个无参构造方法；若自己写了构造方法，则不在默认提供
- 构造方法可以重载

## this：指代当前对象

- 只能用在方法中，方法中访问成员变量之前默认有个this
- 用法：
  - this.成员变量名-----访问成员变量
  - this.方法名()-----调用方法
  - this()-----调用构造方法

## super：指代当前对象的超类

1. super.成员变量名-----访问超类的成员变量
2. super.方法名()-----调用超类的方法
3. super()-----调用超类的构造方法

## 向上造型

> 意义：代码复用

- 超类型的引用指向派生类的对象
- 能点出什么，看引用的类型

## 方法的重写：

- 发生在父子类中，方法名相同，参数列表相同
- 重写被调用是，看对象的类型
- 重写遵循“两同两小一大”原则
  - 两同：
    - 方法名相同
    - 参数列表相同
  - 两小：
    - 派生类方法的返回值类型小于或等于超类方法的
      - void和基本类型时，必须相等
      - 引用类型时，小于或等于
    - 派生类方法抛出的异常小于或等于超类方法
  - 一大：
    - 派生类方法的访问权限大于或冬雨超类方法

> 重写与重载的区别：
>
> - 重写：发生在父子类中，方法名相同，参数列表相同
> - 重载：发生在同一类中，方法名相同，参数列表不同

## package和import

- package：声明包
  - 避免类的命名冲突
  - 同包中的类不能同名，但不同包中的类可以同名
  - 类的全称：包名.类名
  - 包名常常用层次结构，建议所有字母都小写
- import：导入类
  - 同包中的类可以直接方法
  - 不用包的类不能直接访问，若想访问：
    1. 先import声明类，再访问类
    2. 类的全称

## 访问控制修饰符

- public：公开的，任何类
- private：私有的，本类
- protected：受保护的，本类、派生类、同包类
- 默认的：什么都不写，本类、同包类

> - 类的访问权限只能是public或默认的
> - 类中成员的访问权限以上4中都可以
> - 反问权限由高到低：public>protected>默认的>private

## final：

- 修饰变量：不能改变
- 修饰方法：不能被重写
- 修饰类：不能被继承

## static：

- 静态变量：
  - 由static修饰
  - 属于类，存储在方法区中，只有一份
  - 常常通过类名点来访问
  - 何时用：所有对象所共享的数据(图片、音频、视频等)
- 静态方法：
  - 由static修饰
  - 属于类，存储在方法区中，只有一份
  - 常常通过类名点来访问
  - 静态方法中没有隐式this传递，不能直接访问实例成员
  - 何时用：方法的操作与对象无关
- 静态块：
  - 由static修饰
  - 属于类，在类被加载期间自动执行，一个类只被加载一次，所以静态块只执行一次
  - 何时用：加载/初始化静态资源(图片、音频、视频等)

## static final：

- 必须声明同时初始化
- 类名点来访问，不能被改变
- 常量名所有字母都大写，多个单词用_分隔
- 编译器在编译时会将常量直接替换为具体的值
- 何时用：数据永远不变，并且经常使用

## 抽象方法

- 由abstract修饰
- 只有方法的定义，没有具体的实现

## 抽象类

- 由abstract修饰
- 包含抽象方法的类必须是抽象类
- 抽象类不能被实例化（new对象）
- 抽象类是需要被继承的，派生类
  - 重写所有抽象方法
  - 也声明为抽象类
- 抽象类的意义
  - 封装共有的属性和行为（代码复用）
  - 为所有派生类提供统一的类型（向上造型）
  - 可以包含抽象方法，为所有派生类提供统一的入口，派生类的行为不同，但入口一致，同时相当于定义了一个标准（强制重写）

## 成员内部类

- 类中套类，外面的称为外部类，里面的称为内部类
- 内部类通常只服务于外部类，对外不具备可见性
- 内部类对象通常在外部类中创建
- 内部类中可以直接访问外部类的成员（包括私有），内部类中有个隐式的引用指向了创建它的外部类对象：外部类名.this

## 匿名内部类

- 若想创建一个类的对象，并且对象只被创建一次，可以错正匿名内部类
- 在匿名内部类中默认外面的变量为final的
- 内部类有独立的class

## 接口

- 是一种引用数据类型
- 由interface定义
- 只能包含常量和抽象方法
- 接口不能被实例化
- 接口是需要被实现、继承的，实现类、派生类：必须重写所有抽象方法
- 一个类可以实现多个接口，有逗号分隔，若又继承又实现，应先继承后实现
- 接口可以继承接口